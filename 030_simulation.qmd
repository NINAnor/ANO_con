# Simulation

Before we create the samples, we will make a small test, or simulation, just to see that the code is working the way we expect it to.

The plan is to make hierarchical, stratified and balanced samples, with pps (probability proportional to size).

We will borrow code from Brus' book on spatial sampling: <https://dickbrus.github.io/SpatialSamplingwithR/>,
especially from [here](https://github.com/DickBrus/SpatialSamplingwithR/blob/3559338db9a36bfde5844d4671b97366f5cd5152/09-BalancedandSpreaded.Rmd#L350).

## Create dummy dataset

```{r setipSim}
#| include: false
#| message: false
#| eval: true
library(tidyverse)
library(ggpubr)
library(DT)
library(knitr)
library(BalancedSampling)
library(sampling)
library(mase)
```

```{r dummyData}
#| eval: true
# Create two variables with 60 values
s1 <- s2 <- 1:60 - 0.5

# set the per strata sample size
n = 5

# expand to get every combination
# These will act as coordinates for our dummy data 
mypop <- expand.grid(s1, s2)

# name columns
names(mypop) <- c("Easting", "Northing")

# add column 'stratum'
# Strata '0' for when s1 is between -Inf and 4; 
# Strata '1' for when s1 is between 4 and 6; etc.
#mypop$stratum <- as.factor(findInterval(mypop$Easting, c(4, 6, 14)))
mypop$stratum <- as.factor(findInterval(mypop$Easting, c(12, 18, 42)))

# give the strata names as capital letters
levels(mypop$stratum) <- LETTERS[1:4]

# add a column for area that can be used for pps
mypop <- mypop |>
  mutate(area = case_when(
    Northing > 30 ~ 1,
    .default = 0.3
  ))

mypop <- mypop |>
  # get population size N,
  # and the population area A_h,
  # for each strata
    group_by(stratum) |>
    summarise(N_h = n(),
              A_h = sum(area), .groups = "drop") |>
  # calculate inclusion probability (pi) per strata, assuming we will sample 5 units
    mutate(pi_h = rep(n, 4) / N_h) |>
  # join with the original data frame
    right_join(mypop, by = "stratum") |>
   # adding also a pi based on the total area for each strata
    mutate(pi_area = n * area / A_h,
   # add unique ID's to each population unit
           ID = row_number(),
   # add mean values for response variables
           res1_mean = case_when(
             stratum == "A" ~ 5,
             stratum == "B" ~ 10,
             stratum == "C" ~ 15,
             stratum == "D" ~ 20),
           res2_mean = case_when(
             stratum == "A" ~ 50,
             stratum == "B" ~ 10,
             stratum == "C" ~ 30,
             stratum == "D" ~ 14,
                   )) |>
  # create dummy response variables
  group_by(stratum) |>
  mutate(res1 = rnorm(n = n(), mean = res1_mean, sd = 1),
         res2 = rnorm(n = n(), mean = res2_mean, sd = 3),
  # add dummy auxiliary variables
         aux1 = seq(0.5,5.5, length.out = n())^2,
         aux2 = rgamma(n = n(), shape = .4)) |>
  ungroup() |>
  # round values (but don't round the probabilities)
  mutate(across(starts_with(c("aux", "res")), \(x) round(x, 3))) |>
  dplyr::select(-res1_mean, -res2_mean)

```

```{r tbl-dummyData}
#| eval: true
#| tbl-cap: 'Dummy data'
DT::datatable(mypop)

```

The probabilities all sum to the target _n_:
```{r}
mypop |>
  group_by(stratum) |>
  summarise(sum_pi_h = sum(pi_h),
            sum_pi_area = sum(pi_area),
            sum_area = sum(area))
```

```{r fig-hist}
#| eval: true
#| fig-cap: 'Histogram of response and auxilary variables in the dummy dataset.'
#| message: false
mypop |>
  pivot_longer(cols = starts_with(c("res", "aux"))) |>
  ggplot() +
  geom_histogram(aes(value),
    bins = 50
  ) +
  facet_grid(
    rows = vars(stratum), cols = vars(name),
    scales = "free"
  ) +
  theme_bw()
```

```{r tbl-dummySummaryAll}
#| tbl-cap: 'Population seans. The aux variables are not correlated to the strata, but the res (response) variables do differ between strata.'
#| eval: true
tableOfMeans <- mypop |>
  pivot_longer(
    cols = starts_with(c("res", "aux", "North", "East")),
    names_to = "variable", values_to = "values"
  ) |>
  group_by(variable) |>
  summarise("Population mean" = round(mean(values), 2),
            "Population variance" = round(var(values), 2)) |>
  pivot_longer(cols = ends_with("mean")) |>
  select(Variable = variable, 
         Sample = name,
         mean = value, 
         variance = "Population variance") |>
  mutate(Sample = "Population")

tableOfMeans |>
  kable()

```

```{r tbl-dummySummary}
#| tbl-cap: 'Means for each strata. The aux variables are not correlated to the strata, but the res (response) variables do differ between strata.'
#| eval: true
mypop |>
  pivot_longer(
    cols = starts_with(c("res", "aux")),
    names_to = "variable", values_to = "values"
  ) |>
  group_by(variable, stratum) |>
  summarise(mean = round(mean(values), 2)) |>
  kable()

```

```{r fig-fiveMaps}
#| eval: true
#| fig-cap: 'Spatial distribution of the strata, and the four variables in the dummy dataset.'

lw <- .1
ggpubr::ggarrange(
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_d(name = "Stratum") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux1), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "aux1") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux2), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "aux2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res1), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "res1") +
    coord_fixed(),
  
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res2), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "res2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(area)), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_d(name = "area") +
    coord_fixed()
)
```

## Stratified simple random sample (SSRS)

Then I use the cube method in to select a sample balanced on the strata, essentially creating a stratified simple random sample.
Here I use the `sampling` package. This is just a simple first test.

```{r tbl-modelMatrix}
#| eval: true
#| tbl-cap: 'Model matrix'
# Create model matrix by expanding the strata column, explicitly assigning both presences and absences to each row.
X <- model.matrix(~ stratum -1, mypop)
DT::datatable(X)
```

```{r fig-bal1}
#| eval: true
#| fig-cap: 'Sample balanced on a categorical variable (strata). This is equivalent to a stratified simple random sample.'
set.seed(314)
sample_ind <- sampling::samplecube(X = X, pik = mypop$pi_h, comment = TRUE, method = 1)
eps <- 1e-6
mysample <- mypop[sample_ind > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

In @fig-bal1, _n_= `r n` for each strata. This is defined by the the sum of the inclusion probability vector, which is `r sum(mypop$pi_h)` in total.

<!-- In `BalancedSampling` the equivalent function is called `cube()`, or `cubestratified()`. -->
<!-- The latter allow you to add the strata as a vector of size N, and it will be automatically added to the probabilities of each unit in the matrix. -->

```{r HTestimatpr}
#| eval: true
#| include: false

vars <- c("Easting", "Northing", "aux1", "aux2", "res1", "res2")

ht_results <- lapply(vars, function(v) {
  y <- mysample[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample$pi_h, var_est = TRUE)
  data.frame(
    SRSS = round(res$pop_mean, 2),
    SRSS_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(SRSS =  mean/SRSS)

tableOfMeans
```


```{r fig-ssrs}
#| eval: true
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 5.'

mypop |>
  ggplot()+
  geom_histogram(aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "blue",
                 colour = "black",
                 alpha = .5)+
  geom_histogram(data = mysample,
                 aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "red",
                 colour = "black",
                 alpha = .5)+
  facet_grid(.~stratum,
             scales = "free_x")
```

## Balanced sample

Now I want to balance the sample on two auxiliary variables, as well as on the strata.

```{r tbl-modelMatrix2}
#| eval: true
#| tbl-cap: 'Model matrix #2'
# Create model matrix 
X2 <- model.matrix(~ stratum + aux1 + aux2 - 1, mypop)
DT::datatable(X2)
```

```{r balanced}
#| eval: true
#| fig-cap: 'Sample balanced on two auxilary variables, as well as the categorical strata.'
set.seed(3141)
sample_ind2 <- sampling::samplecube(X = X2, pik = mypop$pi_h, comment = TRUE, method = 1)
mysample2 <- mypop[sample_ind2 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample2, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

```

```{r HTestimator2}
#| eval: true
#| include: false

ht_results <- lapply(vars, function(v) {
  y <- mysample2[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample2$pi_h, var_est = TRUE)
  data.frame(
    Balanced = round(res$pop_mean, 2),
    Balanced_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(Balanced = mean/Balanced)
tableOfMeans
```

```{r fig-ssrs2}
#| eval: true
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 10.'

mypop |>
  ggplot()+
  geom_histogram(aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "blue",
                 colour = "black",
                 alpha = .5)+
  geom_histogram(data = mysample2,
                 aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "red",
                 colour = "black",
                 alpha = .5)+
  facet_grid(.~stratum,
             scales = "free_x")
```

It appears from comparing @fig-ssrs with @fig-ssrs2 that the latter has a better overlap with the population distribution, although with n = `r n` this is subject to a lot of chance still.


## Balanced and well-spread

The samples do look like they are well-spread already, and not clumped.
This might get different if n was bigger. @fig-higherN does show two and three neighboring cells frequently get selected.

```{r fig-higherN}
#| eval: true
#| fig-cap: 'Balanced sample with n = 40'
mypop <- mypop |>
  mutate(pi_h2 = rep(40, 4) / N_h)

set.seed(3143)
sample_ind5 <- sampling::samplecube(X = X2, pik = mypop$pi_h2, comment = TRUE, method = 1)
mysample5 <- mypop[sample_ind5 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample5, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

We can spread the samples geographically by balancing on the coordinates, but there are better ways, such as the local pivotal method. This is referred to as doubly balanced sampling. In @fig-lcube, sampling units are more spread, but can still occur next to each other.


```{r fig-lcube}
#| eval: true
#| fig-cap: 'Balanced and well-spread sample (n per strata is 40).'

# model matrix, without the strata, which we now can add as a vector on the side
X4 <- model.matrix(~ aux1 + aux2 - 1, mypop)

# define spreading variables (can be UTM coordinates)
Xspread <- cbind(mypop$Easting, mypop$Northing)
set.seed(314)


sample_ind6 <- BalancedSampling::lcubestratified(
  prob = mypop$pi_h2,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample6 <- mypop[sample_ind6,]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample6, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

```
## PPS

Next i want to introduce sampling with ppr. The purpose is that we don't want to spend too much time going to remote places only to find that the sampling unit is mostly just water. We want to reduce the change of selecting those units, but still keep the probability above 0 so that we can use the HT-estimator and get area-representative estimates of the population. 

PPR can be rather complex, and I'm not sure the solution here is the best or most correct. Basically, rather than calculating the inclusion probability as $n/N$, I use $area/sum(area)$. 

```{r}
#| eval: true
set.seed(3143)
sample_ind4 <- BalancedSampling::lcubestratified(
  prob = mypop$pi_area,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample4 <- mypop[sample_ind4, ]

```

```{r tb}
#| eval: true
#| include: false
ht_results <- lapply(vars, function(v) {
  y <- mysample4[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample4$pi_area, var_est = TRUE)
  data.frame(
    PPS = round(res$pop_mean, 2),
    PPS_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(PPS = mean/PPS)
tableOfMeans
```

In our example, using pps disfavored population units below a Northing of 30 (@fig-pps), but kept the _n_ as before. 

```{r fig-pps}
#| eval: true
#| fig-cap: 'Balanced sample with inclusion probability proportional to size (area).'
ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample4, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

# Comparison

The relative differences between the Horvitz-Thompson estimators for the population means is very similar across all our samples. 
Perhaps most surprising is that SSRS was so good with aux2, an exponential variable. But it could also be that n=5 is too little for getting stable and robust measures of deviation. A better validation would be to bootstrap the process and look at the variation in means then. 



```{r tbl-relDiff}
#| tbl-cap: 'Relative differences between HT-estimators for the population mean'
#| eval: true

ht_results <- lapply(vars, function(v) {
  y <- mysample6[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample6$pi_area, var_est = TRUE)
  data.frame(
    Balanced_spread = round(res$pop_mean, 2),
    Balanced_spread_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(Balanced_spread = mean/Balanced_spread)

tableOfMeans |>
  select(!ends_with("var"),
         -mean, -variance, -Sample) |>
  pivot_longer(cols = !Variable) |>
  pivot_wider(names_from = Variable, values_from = value) |>
  kable()
```

## Hierarchical sampling


I want to create hierarchical samples that get reduced sequantially by 10 units each time. 
I can create a new sample based on the previous sample. 
One worry is that any differences between the initial sample and the population can get reproduced, causing a kind of _drift_ in the auxilary variables. 

One option is then to sample, not from the consecutive sample, but from the entire population, and instead set the probabilities (pi) for those that were not already selected, to zero. 

The _pi_ of a unit will then have to be calculated post hoc based on the _n_ of sample it came from, since the _pi_ associated with that specific sampling may be wrong.

Let's create the first large sample, using n = 100.

```{r largeSmaple}
#| eval: true
#| fig-cap: 'Balanced sample (total n = 100) with inclusion probability proportional to size (area).'

# The n is here for the total, and not per strata. 

n <- 100

temp <- mypop |>
      mutate(pi_area = n * area / A_h)

set.seed(3143)
sample_100 <- BalancedSampling::lcubestratified(
  prob = temp$pi_area,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample100 <- mypop[sample_100, ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample100, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

Then we create nested samples.

```{r nestedSamples}
#| eval: true

currentSample <- mysample100

for (n in seq(90,10, -10)) {
  previousSample <- currentSample$ID
  
  temp2 <- mypop |>
      mutate(area = case_when(
        ID %in% previousSample ~ area,
        .default = 0))
  
  
}
pi <- n *mypop$area / sum(mypop$area)

set.seed(3143)
sample_100 <- BalancedSampling::lcubestratified(
  prob = pi,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample100 <- mypop[sample_100, ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample100, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```






