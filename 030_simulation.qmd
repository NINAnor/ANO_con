# Simulation

Before we create the samples, we will make a small test, or simulation, just to see that the code is working the way we expect it to.

The plan is to make hierarchical, stratified and balanced samples, with pps (probability proportional to size).

We will borrow code from Brus' book on spatial sampling: <https://dickbrus.github.io/SpatialSamplingwithR/>,
especially from [here](https://github.com/DickBrus/SpatialSamplingwithR/blob/3559338db9a36bfde5844d4671b97366f5cd5152/09-BalancedandSpreaded.Rmd#L350).

# Create dummy dataset

```{r setipSim}
#| include: false
#| message: false
#| eval: true
library(tidyverse)
library(ggpubr)
library(DT)
library(knitr)
library(BalancedSampling)
library(sampling)
```

```{r dummyData}
#| eval: true
# Create two variables with 20 values
s1 <- s2 <- 1:20 - 0.5

# set the samle size
n = 10

# expand to get every combination
# These will act as coordinates for our dummy data 
mypop <- expand.grid(s1, s2)

# name columns
names(mypop) <- c("Easting", "Northing")

# add column 'stratum'
# Strata '0' for when s1 is between -Inf and 4; 
# Strata '1' for when s1 is between 4 and 6; etc.
mypop$stratum <- as.factor(findInterval(mypop$Easting, c(4, 6, 14)))

# give the strata names as capital letters
levels(mypop$stratum) <- LETTERS[1:4]

mypop <- mypop |>
  # get population size N for each strata
    group_by(stratum) |>
    summarise(N_h = n(), .groups = "drop") |>
  # calculate inclusion probability (pi) per strata, assuming we will sample 5 units
    mutate(pi_h = rep(n, 4) / N_h) |>
  # join with the original data frame
    right_join(mypop, by = "stratum") |>
   # adding also a uniform pi
    mutate(pi_unif = (n*4)/n(),
   # add mean values for response variables
           res1_mean = case_when(
             stratum == "A" ~ 5,
             stratum == "B" ~ 10,
             stratum == "C" ~ 15,
             stratum == "D" ~ 20),
           res2_mean = case_when(
             stratum == "A" ~ 50,
             stratum == "B" ~ 10,
             stratum == "C" ~ 30,
             stratum == "D" ~ 14,
                   )) |>
  # create dummy response variables
  group_by(stratum) |>
  mutate(res1 = rnorm(n = n(), mean = res1_mean, sd = 1),
         res2 = rnorm(n = n(), mean = res2_mean, sd = 3),
  # add dummy auxiliary variables
         aux1 = seq(0.5,5.5, length.out = n())^2,
         aux2 = rgamma(n = n(), shape = .4)) |>
  ungroup() |>
  # round values
  mutate(across(where(is.numeric), \(x) round(x, 3))) |>
  # add a column for area that can be used for pps
  mutate(area = case_when(
    Northing > 5 ~ 1,
    .default = 0.2
  )) |>
  dplyr::select(-res1_mean, -res2_mean)
```

```{r tbl-dummyData}
#| eval: true
#| tbl-cap: 'Dummy data'
DT::datatable(mypop)

```

```{r fig-hist}
#| eval: true
#| fig-cap: 'Histogram of response and auxilary variables in the dummy dataset.'
mypop |>
  pivot_longer(cols = starts_with(c("res", "aux"))) |>
  ggplot()+
  geom_histogram(aes(value),
                 bins = 50)+
  facet_grid(rows = vars(stratum), cols = vars(name),
             scales = "free")+
  theme_bw(
  )
```

```{r tbl-dummySummary}
#| tbl-cap: 'Means for each strata'
#| eval: true
mypop |>
  pivot_longer(cols = starts_with(c("res", "aux")),
               names_to = "variable", values_to = "values") |>
  group_by(variable, stratum) |>
  summarise(mean = mean(values)) |>
  DT::datatable()

```

```{r fig-fiveMaps}
#| eval: true
#| fig-cap: 'Spatial distribution of the strata, and the four variables in the dummy dataset.'

ggpubr::ggarrange(
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), 
              width = 1, height = 1, size = 0.5, colour = "white") +
    scale_fill_viridis_d(name = "Stratum") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux1), 
              width = 1, height = 1, size = 0.5, colour = "white") +
    scale_fill_viridis_c(name = "aux1") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux2), 
              width = 1, height = 1, size = 0.5, colour = "white") +
    scale_fill_viridis_c(name = "aux2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res1), 
              width = 1, height = 1, size = 0.5, colour = "white") +
    scale_fill_viridis_c(name = "res1") +
    coord_fixed(),
  
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res2), 
              width = 1, height = 1, size = 0.5, colour = "white") +
    scale_fill_viridis_c(name = "res2") +
    coord_fixed()
)
```

# Stratified simple random sample

Then I use the cube method in to select a sample balanced on the strata, essentially creating a stratified simple random sample.
Here I use the `sampling` package. This is just a simple first test.

```{r tbl-modelMatrix}
#| eval: true
#| tbl-cap: 'Model matrix'
# Create model matrix by expanding the strata column, explicitly assigning both presences and absences to each row.
X <- model.matrix(~ stratum - 1, mypop)
DT::datatable(X)
```

```{r fig-bal1}
#| eval: true
#| fig-cap: 'Sample balanced on a categorical variable (strata). This is equivalent to a stratified simple random sample.'
set.seed(314)
sample_ind <- sampling::samplecube(X = X, pik = mypop$pi_h, comment = TRUE, method = 1)
eps <- 1e-6
mysample <- mypop[sample_ind > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

In @fig-bal1, _n_= `r n` for each strata, but this is not explicitly defined.
The total _n_ across all strata is defined through the sum of the inclusion probability vector, which is `r sum(mypop$pi_h)`
And then the n for each strata is a consequence of the number of units in each, and the _pi_ for each unit.


In `BalancedSampling` the equivalent function is called `cube()`, or `cubestratified()`.
The latter allow you to add the strata as a vector of size N, and it will be automatically added to the probabilities of each unit in the matrix.

```{r fig-ssrs}
#| eval: true
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 10.'

mypop |>
  ggplot()+
  geom_histogram(aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "blue",
                 colour = "black",
                 alpha = .5)+
  geom_histogram(data = mysample,
                 aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "red",
                 colour = "black",
                 alpha = .5)+
  facet_grid(.~stratum,
             scales = "free_x")
```

# Balanced sample

Now I want to balance the sample on two auxiliary variables, as well as on the strata.

```{r tbl-modelMatrix2}
#| eval: true
#| tbl-cap: 'Model matrix #2'
# Create model matrix 
X2 <- model.matrix(~ stratum + aux1 + aux2 - 1, mypop)
DT::datatable(X2)
```

```{r balanced}
#| eval: true
#| fig-cap: 'Sample baalnced on two auxilary variables, as well as the categorical strata.'
set.seed(3141)
sample_ind2 <- sampling::samplecube(X = X2, pik = mypop$pi_h, comment = TRUE, method = 1)
mysample2 <- mypop[sample_ind2 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample2, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

```


```{r fig-ssrs2}
#| eval: true
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 10.'

mypop |>
  ggplot()+
  geom_histogram(aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "blue",
                 colour = "black",
                 alpha = .5)+
  geom_histogram(data = mysample2,
                 aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "red",
                 colour = "black",
                 alpha = .5)+
  facet_grid(.~stratum,
             scales = "free_x")
```

It appears from comparing @fig-ssrs with @fig-ssrs2 that the latter has a better overlap with the population distribution, altough with n = 10 this is subject to a lot of chance still.

Now I just want to check if it makes a difference if I scale the auxiliary variables

```{r}
#| eval: true
mypop <- mypop |>
  mutate(aux1_s = scale(aux1),
         aux2_s = scale(aux2))
X3 <- model.matrix(~ stratum + aux1_s + aux2_s - 1, mypop)
set.seed(3142)

sample_ind3 <- sampling::samplecube(X = X3, pik = mypop$pi_h, comment = TRUE, method = 1)
mysample3 <- mypop[sample_ind3 > (1 - eps), ]

```



# PPS

Next i want to introduce sampling with ppr.

```{r}
#| eval: true
mypop <- mypop |>
  mutate(pi_pps = pi_h * area)
pi_pps <- mypop |>
  mutate(pi_pps = pi_h * area) |>
  pull(pi_pps)

set.seed(3143)
sample_ind4 <- sampling::samplecube(X = X2, pik = pi_pps, comment = TRUE, method = 1)
mysample4 <- mypop[sample_ind4 > (1 - eps), ]
```


```{r tbl-means}
#| eval: true
#| tbl-cap: 'Comparing the means of four sampling methods against the true population mean. The variable is exponentially associated with latitude and area.'
mypop |>
  summarise(
    True_mean = mean(aux1),
    SRSS     = mean(aux1[sample_ind == 1]),
    Balanced      = mean(aux1[sample_ind2 == 1]),
    Balanced_and_scaled    = mean(aux1[sample_ind3 == 1]),
    PPS  = mean(aux1[sample_ind4 == 1])
    ) |>
  t() |>
  kable()
```

The stratified and balanced sample, without scaling, has the sample mean clostst to the true mean. The pps shifts the mean upwards, as expected, because we under-sample the low latitudes, but this would be corrected in the HT-estimator. Ideally I would do another simulation here and calculate the means 1000 times and get the distribution of means to compare between the methods, but I don't have time now.


# Balanced and well-spread
