# Simulation


```{r setipSim}
#| include: false
#| message: false
#| eval: true
library(tidyverse)
library(ggpubr)
library(DT)
library(knitr)
library(BalancedSampling)
library(sampling)
library(mase)
library(spaceR)
```


Before we create the samples, we will make a small test, or simulation, just to see that the code is working the way we expect it to.

The plan is to make hierarchical, stratified and balanced samples, with pps (probability proportional to size).

We will borrow code from Brus' book on spatial sampling: <https://dickbrus.github.io/SpatialSamplingwithR/>,
especially from [here](https://github.com/DickBrus/SpatialSamplingwithR/blob/3559338db9a36bfde5844d4671b97366f5cd5152/09-BalancedandSpreaded.Rmd#L350).

## Create dummy dataset

I made an R package `spaceR` to house the main function for the ANO sampling. 
In that package I also added a dummy dataset.

```{r}
#| eval: true
#library(spaceR)
data('mypop')
```


```{r tbl-dummyData}
#| eval: true
#| tbl-cap: 'Dummy data'
DT::datatable(mypop)

```

The probabilities all sum to the target _n_.

```{r}
mypop |>
  group_by(stratum) |>
  summarise(sum_pi_h = sum(pi_h),
            sum_pi_area = sum(pi_area),
            sum_area = sum(area))
```

```{r fig-hist}
#| eval: true
#| fig-cap: 'Histogram of response and auxilary variables in the dummy dataset.'
#| message: false
mypop |>
  pivot_longer(cols = starts_with(c("res", "aux"))) |>
  ggplot() +
  geom_histogram(aes(value),
    bins = 50
  ) +
  facet_grid(
    rows = vars(stratum), cols = vars(name),
    scales = "free"
  ) +
  theme_bw()
```

```{r tbl-dummySummaryAll}
#| tbl-cap: 'Population means. The aux variables are not correlated to the strata, but the res (response) variables do differ between strata.'
#| eval: true
tableOfMeans <- mypop |>
  pivot_longer(
    cols = starts_with(c("res", "aux", "North", "East")),
    names_to = "variable", values_to = "values"
  ) |>
  group_by(variable) |>
  summarise("Population mean" = round(mean(values), 2),
            "Population variance" = round(var(values), 2)) |>
  pivot_longer(cols = ends_with("mean")) |>
  select(Variable = variable, 
         Sample = name,
         mean = value, 
         variance = "Population variance") |>
  mutate(Sample = "Population")

tableOfMeans |>
  kable()

```

```{r tbl-dummySummary}
#| tbl-cap: 'Means for each strata. The aux variables are not correlated to the strata, but the res (response) variables do differ between strata.'
#| eval: true
mypop |>
  pivot_longer(
    cols = starts_with(c("res", "aux")),
    names_to = "variable", values_to = "values"
  ) |>
  group_by(variable, stratum) |>
  summarise(mean = round(mean(values), 2)) |>
  kable()

```

```{r fig-fiveMaps}
#| eval: true
#| fig-cap: 'Spatial distribution of the strata, and the four variables in the dummy dataset.'

lw <- .1
ggpubr::ggarrange(
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_d(name = "Stratum") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux1), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "aux1") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux2), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "aux2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res1), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "res1") +
    coord_fixed(),
  
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res2), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "res2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(area)), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_d(name = "area") +
    coord_fixed()
)
```

## Stratified simple random sample (SSRS)

Then I use the cube method in to select a sample balanced on the strata, essentially creating a stratified simple random sample.
Here I use the `sampling` package. This is just a simple first test.

```{r tbl-modelMatrix}
#| eval: true
#| tbl-cap: 'Model matrix'
# Create model matrix by expanding the strata column, explicitly assigning both presences and absences to each row.
X <- model.matrix(~ stratum -1, mypop)
DT::datatable(X)
```

```{r fig-bal1}
#| eval: true
#| fig-cap: 'Sample balanced on a categorical variable (strata). This is equivalent to a stratified simple random sample.'
set.seed(314)
sample_ind <- sampling::samplecube(X = X, pik = mypop$pi_h, comment = TRUE, method = 1)
eps <- 1e-6
mysample <- mypop[sample_ind > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

In @fig-bal1, _n_= 5 for each strata. This is defined by the the sum of the inclusion probability vector, which is `r sum(mypop$pi_h)` in total.

<!-- In `BalancedSampling` the equivalent function is called `cube()`, or `cubestratified()`. -->
<!-- The latter allow you to add the strata as a vector of size N, and it will be automatically added to the probabilities of each unit in the matrix. -->

```{r HTestimatpr}
#| eval: true
#| include: false

vars <- c("Easting", "Northing", "aux1", "aux2", "res1", "res2")

ht_results <- lapply(vars, function(v) {
  y <- mysample[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample$pi_h, var_est = TRUE)
  data.frame(
    SRSS = round(res$pop_mean, 2),
    SRSS_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(SRSS =  mean/SRSS)

tableOfMeans
```


```{r fig-ssrs}
#| eval: false
#| include: false
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 5.'

mypop |>
  ggplot() +
  geom_histogram(aes(x = aux2, y = after_stat(density)),
    binwidth = 1,
    fill = "blue",
    colour = "black",
    alpha = .5
  ) +
  geom_histogram(
    data = mysample,
    aes(x = aux2, y = after_stat(density)),
    binwidth = 1,
    fill = "red",
    colour = "black",
    alpha = .5
  ) +
  facet_grid(. ~ stratum,
    scales = "free_x"
  )
```

## Balanced sample

Now I want to balance the sample on two auxiliary variables, as well as on the strata.

```{r modelMatrix2}
#| eval: true
# Create model matrix 
X2 <- model.matrix(~ stratum + aux1 + aux2 - 1, mypop)
#DT::datatable(X2)
```

```{r fig-balanced}
#| eval: true
#| fig-cap: 'Sample balanced on two auxilary variables, as well as the categorical strata.'
set.seed(3141)
sample_ind2 <- sampling::samplecube(X = X2, pik = mypop$pi_h, comment = TRUE, method = 1)
mysample2 <- mypop[sample_ind2 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample2, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

```



```{r HTestimator2}
#| eval: true
#| include: false

ht_results <- lapply(vars, function(v) {
  y <- mysample2[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample2$pi_h, var_est = TRUE)
  data.frame(
    Balanced = round(res$pop_mean, 2),
    Balanced_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(Balanced = mean/Balanced)
tableOfMeans
```

```{r fig-ssrs2}
#| eval: false
#| include: false
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 10.'

mypop |>
  ggplot()+
  geom_histogram(aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "blue",
                 colour = "black",
                 alpha = .5)+
  geom_histogram(data = mysample2,
                 aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "red",
                 colour = "black",
                 alpha = .5)+
  facet_grid(.~stratum,
             scales = "free_x")
```


## Balanced and well-spread

The samples do look like they are well-spread already, and not clumped.
This might get different if n was bigger. @fig-higherN shows how two and three neighboring cells frequently get selected.

```{r fig-higherN}
#| eval: true
#| fig-cap: 'Balanced sample with n = 40'
mypop <- mypop |>
  mutate(pi_h2 = rep(40, 4) / N_h)

set.seed(3143)
sample_ind5 <- sampling::samplecube(X = X2, pik = mypop$pi_h2, comment = TRUE, method = 1)
mysample5 <- mypop[sample_ind5 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample5, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

#ggsave("img/balanced.png")
```

We can spread the samples geographically by balancing on the coordinates, but there are better ways, such as the local pivotal method. This is referred to as doubly balanced sampling. In @fig-lcube, sampling units are more spread, but can still occur next to each other.


```{r fig-lcube}
#| eval: true
#| fig-cap: 'Balanced and well-spread sample (n per strata is 40).'

# model matrix, without the strata, which we now can add as a vector on the side
X4 <- model.matrix(~ aux1 + aux2 - 1, mypop)

# define spreading variables (can be UTM coordinates)
Xspread <- cbind(mypop$Easting, mypop$Northing)
set.seed(314)


sample_ind6 <- BalancedSampling::lcubestratified(
  prob = mypop$pi_h2,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample6 <- mypop[sample_ind6,]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample6, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
#ggsave("img/balanced_well_spread.png")
```


## PPS

Next i want to introduce sampling with ppr. The purpose is that we don't want to spend too much time going to remote places only to find that the sampling unit is mostly just water. We want to reduce the change of selecting those units, but still keep the probability above 0 so that we can use the HT-estimator and get area-representative estimates of the population. 

PPR can be rather complex, and I'm not sure the solution here is the best or most correct. Basically, rather than calculating the inclusion probability as $n/N$, I use $area/sum(area)$. 

```{r}
#| eval: true
set.seed(3143)
sample_ind4 <- BalancedSampling::lcubestratified(
  prob = mypop$pi_area,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample4 <- mypop[sample_ind4, ]

```

```{r tb}
#| eval: true
#| include: false
ht_results <- lapply(vars, function(v) {
  y <- mysample4[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample4$pi_area, var_est = TRUE)
  data.frame(
    PPS = round(res$pop_mean, 2),
    PPS_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(PPS = mean/PPS)
tableOfMeans
```

In our example, using pps disfavored population units below a Northing of 30 (@fig-pps), but kept the _n_ as before. 

```{r fig-pps}
#| eval: true
#| fig-cap: 'Balanced sample with inclusion probability proportional to size (area).'
ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample4, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

## Comparison


```{r voronoi}
#| eval: true
voronoi_ssrs <- BalancedSampling::sb(mypop$pi_h, X2, which(sample_ind>(1-eps)))
voronoi_bal <- BalancedSampling::sb(mypop$pi_h, X2, which(sample_ind2>(1-eps)))
voronoi_bal2 <- BalancedSampling::sb(mypop$pi_h, X2, which(sample_ind5>(1-eps)))
voronoi_bal_spred <- BalancedSampling::sb(mypop$pi_h, X2, which(sample_ind6>(1-eps)))
```

The voronoi measure of spatial balance, as a ratio against SSRS, is:

- Balanced sample: `r voronoi_bal/voronoi_ssrs`
- Balanced sample with large n: `r voronoi_bal2/voronoi_ssrs`
- Balanced and well-spread: `r voronoi_bal_spred/voronoi_ssrs`

In other words, the balanced and well spread is considerably better than just balanced, and all balanced samples re considerably better than simple random samples. We did not includ pps in this comparison.


The relative differences between the Horvitz-Thompson estimators for the population means is very similar across all our samples. Aux2 is providing the best test of balance perhaps, because it is an exponential variable. The balanced and well-spread sample had the smallest relative deviation for thet variable. But it could also be that n=5 is too little for getting stable and robust measures of deviation. A better validation would be to bootstrap the process and look at the variation in means then. 


```{r tbl-relDiff}
#| tbl-cap: 'Relative differences between HT-estimators for the population mean'
#| eval: true

ht_results <- lapply(vars, function(v) {
  y <- mysample6[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample6$pi_area, var_est = TRUE)
  data.frame(
    Balanced_spread = round(res$pop_mean, 2),
    Balanced_spread_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(Balanced_spread = mean/Balanced_spread)

tableOfMeans |>
  select(!ends_with("var"),
         -mean, -variance, -Sample) |>
  pivot_longer(cols = !Variable) |>
  pivot_wider(names_from = Variable, values_from = value) |>
  kable()
```



## Hierarchical sampling


I want to create hierarchical samples that get reduced sequentially by _x_ number of units each time. I will use x = 20 here to keep things simple.
I can create a new sample based on the previous sample, but
one worry is that any differences between the initial sample and the population can get reproduced, causing a kind of _drift_ in the auxilary variables. 

One option is then to sample, not from the consecutive sample, but from the entire population, and instead set the probabilities (pi) for those that were not already selected, to zero. That way the sub-samples are still balanced relative to the entire population.

The spatial spreading, however, is best to recalculate for each subsequent sample. Therefore we calculate `Xspread` again each time, but offsetting he coordinates of those population units with probabilities = 0.

```{r}
#| eval: true
h_samples <- nested_balanced(mypop,
  n_seq = seq(100, 20, -20),
  id_col = "myids",
  stratum_col = "stratum",
  easting_col = "Easting",
  northing_col = "Northing",
  area_col = "area2",
  xbal_formula = ~aux1+aux2-1,
  exclude_offset = 1e+06,
  return_dataframe = TRUE,
  quiet = TRUE)
```


```{r}
#| eval: true

n100 <- mypop |>
  filter(ID %in% h_samples$mysample_100$ID)
n20 <- mypop |>
  filter(ID %in% h_samples$mysample_20$ID)

ggplot(data = mypop) +
  geom_tile(
    mapping = aes(x = Easting, y = Northing, fill = factor(stratum)),
    width = 1, height = 1, size = 0.5, colour = "white"
  ) +
  geom_tile(
    data = n100, mapping = aes(x = Easting, y = Northing),
    fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black"
  ) +
  geom_tile(
    data = n20, mapping = aes(x = Easting, y = Northing),
    fill = "white", width = 1, height = 1, linewidth = 0.7, colour = "black"
  ) +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```


```{r}
#| eval: true
all_selected <- c(
  h_samples$mysample_100$ID,
  h_samples$mysample_80$ID,
  h_samples$mysample_60$ID,
  h_samples$mysample_40$ID,
  h_samples$mysample_20$ID
)
```


```{r fig-no}
#| eval: true
#| fig-cap: 'Figure showing the selected population units, and how many of the in total five nestes samples they were included in. Legend title translates to "Number of times selected".'
 all_selected |>
  as_tibble() |>
  rename(ID = value) |>
  group_by(ID) |>
  summarise(no_selected = n()) |>
  right_join(mypop, by = "ID") |>
  ggplot() +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(no_selected)), 
            width = 1, height = 1, linewidth = 0.5, colour = "white") +
  scale_fill_viridis_d(name = "Antall ganger\nenheten er valgt", 
                       option = "C", direction = -1, na.translate = F) +
  coord_fixed()
 
#ggsave("img/antallGangerValgt.png")
```


## Whats the pi? {#sec-what}

The inclusion probabilities are accumulated for each iteration of sampling. the initial pps sampling
usually has the lowest probabilities, esp. if the population >> sample. 
We can access the accumulated probabilities in the output 

```{r}
h_samples$mysample_100$accumulated_pi[1:10]
```

```{r}
h_samples$mysample_20$accumulated_pi[1:10]

```



