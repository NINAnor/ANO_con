# Simulation

Before we create the samples, we will make a small test, or simulation, just to see that the code is working the way we expect it to.

The plan is to make hierarchical, stratified and balanced samples, with pps (probability proportional to size).

We will borrow code from Brus' book on spatial sampling: <https://dickbrus.github.io/SpatialSamplingwithR/>,
especially from [here](https://github.com/DickBrus/SpatialSamplingwithR/blob/3559338db9a36bfde5844d4671b97366f5cd5152/09-BalancedandSpreaded.Rmd#L350).

## Create dummy dataset

```{r setipSim}
#| include: false
#| message: false
#| eval: true
library(tidyverse)
library(ggpubr)
library(DT)
library(knitr)
library(BalancedSampling)
library(sampling)
library(mase)
```

```{r dummyData}
#| eval: true
# Create two variables with 60 values
s1 <- s2 <- 1:60 - 0.5

# set the per strata sample size
n <- 5

# expand to get every combination
# These will act as coordinates for our dummy data
mypop <- expand.grid(s1, s2)

# name columns
names(mypop) <- c("Easting", "Northing")

# add column 'stratum'
# Strata '0' for when s1 is between -Inf and 4;
# Strata '1' for when s1 is between 4 and 6; etc.
# mypop$stratum <- as.factor(findInterval(mypop$Easting, c(4, 6, 14)))
mypop$stratum <- as.factor(findInterval(mypop$Easting, c(12, 18, 42)))

# give the strata names as capital letters
levels(mypop$stratum) <- LETTERS[1:4]

# add a column for area that can be used for pps
mypop <- mypop |>
  mutate(
    area = case_when(
      Northing > 30 ~ 1,
      .default = 0.3
    ),
    area2 = case_when(
      Northing > 10 ~ 1,
      .default = 0.5
    )
  )

mypop <- mypop |>
  # get population size N,
  # and the population area A_h,
  # for each strata
  group_by(stratum) |>
  summarise(
    N_h = n(),
    A_h = sum(area),
    A_h2 = sum(area2), 
    .groups = "drop"
  ) |>
  # calculate inclusion probability (pi) per strata, assuming we will sample 5 units
  mutate(pi_h = rep(n, 4) / N_h) |>
  # join with the original data frame
  right_join(mypop, by = "stratum") |>
  # adding also a pi based on the total area for each strata
  mutate(pi_area = n * area / A_h,
    # add unique ID's to each population unit
    ID = row_number(),
    # add mean values for response variables
    res1_mean = case_when(
      stratum == "A" ~ 5,
      stratum == "B" ~ 10,
      stratum == "C" ~ 15,
      stratum == "D" ~ 20
    ),
    res2_mean = case_when(
      stratum == "A" ~ 50,
      stratum == "B" ~ 10,
      stratum == "C" ~ 30,
      stratum == "D" ~ 14,
    )
  ) |>
  # create dummy response variables
  group_by(stratum) |>
  mutate(
    res1 = rnorm(n = n(), mean = res1_mean, sd = 1),
    res2 = rnorm(n = n(), mean = res2_mean, sd = 3),
    # add dummy auxiliary variables
    aux1 = seq(0.5, 5.5, length.out = n())^2,
    aux2 = rgamma(n = n(), shape = .4)
  ) |>
  ungroup() |>
  # round values (but don't round the probabilities)
  mutate(across(starts_with(c("aux", "res")), \(x) round(x, 3))) |>
  dplyr::select(-res1_mean, -res2_mean)

```

```{r tbl-dummyData}
#| eval: true
#| tbl-cap: 'Dummy data'
DT::datatable(mypop)

```

The probabilities all sum to the target _n_:
```{r}
mypop |>
  group_by(stratum) |>
  summarise(sum_pi_h = sum(pi_h),
            sum_pi_area = sum(pi_area),
            sum_area = sum(area))
```

```{r fig-hist}
#| eval: true
#| fig-cap: 'Histogram of response and auxilary variables in the dummy dataset.'
#| message: false
mypop |>
  pivot_longer(cols = starts_with(c("res", "aux"))) |>
  ggplot() +
  geom_histogram(aes(value),
    bins = 50
  ) +
  facet_grid(
    rows = vars(stratum), cols = vars(name),
    scales = "free"
  ) +
  theme_bw()
```

```{r tbl-dummySummaryAll}
#| tbl-cap: 'Population seans. The aux variables are not correlated to the strata, but the res (response) variables do differ between strata.'
#| eval: true
tableOfMeans <- mypop |>
  pivot_longer(
    cols = starts_with(c("res", "aux", "North", "East")),
    names_to = "variable", values_to = "values"
  ) |>
  group_by(variable) |>
  summarise("Population mean" = round(mean(values), 2),
            "Population variance" = round(var(values), 2)) |>
  pivot_longer(cols = ends_with("mean")) |>
  select(Variable = variable, 
         Sample = name,
         mean = value, 
         variance = "Population variance") |>
  mutate(Sample = "Population")

tableOfMeans |>
  kable()

```

```{r tbl-dummySummary}
#| tbl-cap: 'Means for each strata. The aux variables are not correlated to the strata, but the res (response) variables do differ between strata.'
#| eval: true
mypop |>
  pivot_longer(
    cols = starts_with(c("res", "aux")),
    names_to = "variable", values_to = "values"
  ) |>
  group_by(variable, stratum) |>
  summarise(mean = round(mean(values), 2)) |>
  kable()

```

```{r fig-fiveMaps}
#| eval: true
#| fig-cap: 'Spatial distribution of the strata, and the four variables in the dummy dataset.'

lw <- .1
ggpubr::ggarrange(
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_d(name = "Stratum") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux1), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "aux1") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = aux2), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "aux2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res1), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "res1") +
    coord_fixed(),
  
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = res2), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_c(name = "res2") +
    coord_fixed(),
  
  ggplot(data = mypop) +
    geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(area)), 
              width = 1, height = 1, linewidth = lw, colour = "white") +
    scale_fill_viridis_d(name = "area") +
    coord_fixed()
)
```

## Stratified simple random sample (SSRS)

Then I use the cube method in to select a sample balanced on the strata, essentially creating a stratified simple random sample.
Here I use the `sampling` package. This is just a simple first test.

```{r tbl-modelMatrix}
#| eval: true
#| tbl-cap: 'Model matrix'
# Create model matrix by expanding the strata column, explicitly assigning both presences and absences to each row.
X <- model.matrix(~ stratum -1, mypop)
DT::datatable(X)
```

```{r fig-bal1}
#| eval: true
#| fig-cap: 'Sample balanced on a categorical variable (strata). This is equivalent to a stratified simple random sample.'
set.seed(314)
sample_ind <- sampling::samplecube(X = X, pik = mypop$pi_h, comment = TRUE, method = 1)
eps <- 1e-6
mysample <- mypop[sample_ind > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

In @fig-bal1, _n_= `r n` for each strata. This is defined by the the sum of the inclusion probability vector, which is `r sum(mypop$pi_h)` in total.

<!-- In `BalancedSampling` the equivalent function is called `cube()`, or `cubestratified()`. -->
<!-- The latter allow you to add the strata as a vector of size N, and it will be automatically added to the probabilities of each unit in the matrix. -->

```{r HTestimatpr}
#| eval: true
#| include: false

vars <- c("Easting", "Northing", "aux1", "aux2", "res1", "res2")

ht_results <- lapply(vars, function(v) {
  y <- mysample[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample$pi_h, var_est = TRUE)
  data.frame(
    SRSS = round(res$pop_mean, 2),
    SRSS_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(SRSS =  mean/SRSS)

tableOfMeans
```


```{r fig-ssrs}
#| eval: true
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 5.'

mypop |>
  ggplot() +
  geom_histogram(aes(x = aux2, y = after_stat(density)),
    binwidth = 1,
    fill = "blue",
    colour = "black",
    alpha = .5
  ) +
  geom_histogram(
    data = mysample,
    aes(x = aux2, y = after_stat(density)),
    binwidth = 1,
    fill = "red",
    colour = "black",
    alpha = .5
  ) +
  facet_grid(. ~ stratum,
    scales = "free_x"
  )
```

## Balanced sample

Now I want to balance the sample on two auxiliary variables, as well as on the strata.

```{r tbl-modelMatrix2}
#| eval: true
#| tbl-cap: 'Model matrix #2'
# Create model matrix 
X2 <- model.matrix(~ stratum + aux1 + aux2 - 1, mypop)
DT::datatable(X2)
```

```{r fig-balanced}
#| eval: true
#| fig-cap: 'Sample balanced on two auxilary variables, as well as the categorical strata.'
set.seed(3141)
sample_ind2 <- sampling::samplecube(X = X2, pik = mypop$pi_h, comment = TRUE, method = 1)
mysample2 <- mypop[sample_ind2 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample2, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

```

```{r HTestimator2}
#| eval: true
#| include: false

ht_results <- lapply(vars, function(v) {
  y <- mysample2[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample2$pi_h, var_est = TRUE)
  data.frame(
    Balanced = round(res$pop_mean, 2),
    Balanced_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(Balanced = mean/Balanced)
tableOfMeans
```

```{r fig-ssrs2}
#| eval: true
#| fig-cap: 'Histograms comparing the population distribution (blue, gamma distribution) with the sample from a stratified simple random sample when n = 10.'

mypop |>
  ggplot()+
  geom_histogram(aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "blue",
                 colour = "black",
                 alpha = .5)+
  geom_histogram(data = mysample2,
                 aes(x = aux2, y = after_stat(density)),
                 binwidth = 1,
                 fill = "red",
                 colour = "black",
                 alpha = .5)+
  facet_grid(.~stratum,
             scales = "free_x")
```

It appears from comparing @fig-ssrs with @fig-ssrs2 that the latter has a better overlap with the population distribution, although with n = `r n` this is subject to a lot of chance still.


## Balanced and well-spread

The samples do look like they are well-spread already, and not clumped.
This might get different if n was bigger. @fig-higherN shows how two and three neighboring cells frequently get selected.

```{r fig-higherN}
#| eval: true
#| fig-cap: 'Balanced sample with n = 40'
mypop <- mypop |>
  mutate(pi_h2 = rep(40, 4) / N_h)

set.seed(3143)
sample_ind5 <- sampling::samplecube(X = X2, pik = mypop$pi_h2, comment = TRUE, method = 1)
mysample5 <- mypop[sample_ind5 > (1 - eps), ]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample5, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

We can spread the samples geographically by balancing on the coordinates, but there are better ways, such as the local pivotal method. This is referred to as doubly balanced sampling. In @fig-lcube, sampling units are more spread, but can still occur next to each other.


```{r fig-lcube}
#| eval: true
#| fig-cap: 'Balanced and well-spread sample (n per strata is 40).'

# model matrix, without the strata, which we now can add as a vector on the side
X4 <- model.matrix(~ aux1 + aux2 - 1, mypop)

# define spreading variables (can be UTM coordinates)
Xspread <- cbind(mypop$Easting, mypop$Northing)
set.seed(314)


sample_ind6 <- BalancedSampling::lcubestratified(
  prob = mypop$pi_h2,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample6 <- mypop[sample_ind6,]

ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample6, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()

```
## PPS

Next i want to introduce sampling with ppr. The purpose is that we don't want to spend too much time going to remote places only to find that the sampling unit is mostly just water. We want to reduce the change of selecting those units, but still keep the probability above 0 so that we can use the HT-estimator and get area-representative estimates of the population. 

PPR can be rather complex, and I'm not sure the solution here is the best or most correct. Basically, rather than calculating the inclusion probability as $n/N$, I use $area/sum(area)$. 

```{r}
#| eval: true
set.seed(3143)
sample_ind4 <- BalancedSampling::lcubestratified(
  prob = mypop$pi_area,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
mysample4 <- mypop[sample_ind4, ]

```

```{r tb}
#| eval: true
#| include: false
ht_results <- lapply(vars, function(v) {
  y <- mysample4[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample4$pi_area, var_est = TRUE)
  data.frame(
    PPS = round(res$pop_mean, 2),
    PPS_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(PPS = mean/PPS)
tableOfMeans
```

In our example, using pps disfavored population units below a Northing of 30 (@fig-pps), but kept the _n_ as before. 

```{r fig-pps}
#| eval: true
#| fig-cap: 'Balanced sample with inclusion probability proportional to size (area).'
ggplot(data = mypop) +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(stratum)), width = 1, height = 1, size = 0.5, colour = "white") +
  geom_tile(data = mysample4, mapping = aes(x = Easting, y = Northing), fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black") +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

## Comparison

The relative differences between the Horvitz-Thompson estimators for the population means is very similar across all our samples. Aux2 is providing the best tet of balance perhaps, because it is an exponential variable. The balanced and well-spread sample had the smallest relative deviation for thet variable. But it could also be that n=5 is too little for getting stable and robust measures of deviation. A better validation would be to bootstrap the process and look at the variation in means then. 



```{r tbl-relDiff}
#| tbl-cap: 'Relative differences between HT-estimators for the population mean'
#| eval: true

ht_results <- lapply(vars, function(v) {
  y <- mysample6[[v]]
  res <- mase::horvitzThompson(y = y, pi = mysample6$pi_area, var_est = TRUE)
  data.frame(
    Balanced_spread = round(res$pop_mean, 2),
    Balanced_spread_var = round(res$pop_mean_var,2)
  )
}) %>%
  bind_rows()

tableOfMeans <- tableOfMeans |>
  cbind(ht_results) |>
  mutate(Balanced_spread = mean/Balanced_spread)

tableOfMeans |>
  select(!ends_with("var"),
         -mean, -variance, -Sample) |>
  pivot_longer(cols = !Variable) |>
  pivot_wider(names_from = Variable, values_from = value) |>
  kable()
```

## Hierarchical sampling


I want to create hierarchical samples that get reduced sequentially by _x_ number of units each time. I will use x = 20 here to keep things simple.
I can create a new sample based on the previous sample, but
one worry is that any differences between the initial sample and the population can get reproduced, causing a kind of _drift_ in the auxilary variables. 

One option is then to sample, not from the consecutive sample, but from the entire population, and instead set the probabilities (pi) for those that were not already selected, to zero. That way the sub-samples are still balanced relative to the entire population.

The _pi_ of a unit will then have to be calculated _post hoc_ based on the _n_ of the sample it came from (@sec-what).

Let's create the first large sample, using n = 100. Because we really exaggerated the `area` variable, we could get the remaining area (the summed area in the sampled) to be less than the next sample size. Therefore I will use `area2` which make the differences in area a little less dramatic. 


```{r largeSmaple}
#| eval: true
#| fig-cap: 'Balanced sample (total n = 100) with inclusion probability proportional to size (area).'

# The n is per strata. 
n <- 100

temp <- mypop |>
      mutate(pi = n * area2 / A_h2)

# Sums are OK:
#temp |>
#  group_by(stratum) |>
#  summarise(pi_summed = sum(pi))

set.seed(3143)
sample_100_indices <- BalancedSampling::lcubestratified(
  prob = temp$pi,
  Xspread = Xspread,
  Xbal = X4,
  integerStrat = mypop$stratum)
sample_100 <- mypop[sample_100_indices, ]

ggplot(data = mypop) +
  geom_tile(
    mapping = aes(x = Easting, y = Northing, fill = factor(stratum)),
    width = 1, height = 1, size = 0.5, colour = "white"
  ) +
  geom_tile(
    data = sample_100, mapping = aes(x = Easting, y = Northing),
    fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black"
  ) +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

Then we create nested samples. 


```{r nestedSamples}
#| eval: true

currentSample <- sample_100

all_selected <- currentSample$ID

for (n in seq(80, 20, -20)) {
  # print(n)
  previousSample <- currentSample$ID

  Xspread <- tibble(
    E = mypop$Easting,
    N = mypop$Northing
  ) |>
    mutate(
      ID = row_number(),
      E = case_when(
        ID %in% previousSample ~ E,
        .default = 999
      ), # tested with 30 to see if we got a bias, but no
      N = case_when(
        ID %in% previousSample ~ N,
        .default = 999
      )
    ) |>
    select(-ID) |>
    as.matrix()

  temp <- mypop |>
    mutate(area2 = case_when(
      ID %in% previousSample ~ area2,
      .default = 0
    ))

  temp <- temp |>
    group_by(stratum) |>
    summarise(remainingArea = sum(area2), .groups = "drop") |>
    right_join(temp, by = "stratum") |>
    mutate(pi = n * area2 / remainingArea)

  sample_indices <- BalancedSampling::lcubestratified(
    prob = temp$pi,
    Xspread = Xspread,
    Xbal = X4,
    integerStrat = mypop$stratum
  )

  currentSample <- mypop[sample_indices, ]

  assign(paste0("sample_", n), currentSample)
  all_selected <- c(all_selected, currentSample$ID)
}

```



```{r fig-no}
#| eval: true
#| fig-cap: 'Figure showing the selected population units, and how many of the in total five nestes samples they were included in.'
 all_selected |>
  as_tibble() |>
  rename(ID = value) |>
  group_by(ID) |>
  summarise(no_selected = n()) |>
  right_join(mypop, by = "ID") |>
  ggplot() +
  geom_tile(mapping = aes(x = Easting, y = Northing, fill = factor(no_selected)), 
            width = 1, height = 1, linewidth = 0.5, colour = "white") +
  scale_fill_viridis_d(name = "Number of times selected", option = "C", direction = -1) +
  coord_fixed()
```

```{r fig-finalSample}
#| eval: true
#| fig-cap: 'The smalles of the hierarchical samples (n = 20).'
ggplot(data = mypop) +
  geom_tile(
    mapping = aes(x = Easting, y = Northing, fill = factor(stratum)),
    width = 1, height = 1, size = 0.5, colour = "white"
  ) +
  geom_tile(
    data = sample_20, mapping = aes(x = Easting, y = Northing),
    fill = NA, width = 1, height = 1, linewidth = 0.7, colour = "black"
  ) +
  scale_fill_viridis_d(name = "Stratum") +
  coord_fixed()
```

It still a question whether the final or smallest sample (@fig-finalSample) is balanced. A superfical analyses tells us it's looking good (@fig-finalBal).


```{r fig-finalBal}
#| eval: true
#| fig-cap: 'Histograms comparing the smallest of the nested samples (red) against the true population (blue).'
mypop |>
  ggplot() +
  geom_histogram(aes(x = aux2, y = after_stat(density)),
    binwidth = 1,
    fill = "blue",
    colour = "black",
    alpha = .5
  ) +
  geom_histogram(
    data = sample_20,
    aes(x = aux2, y = after_stat(density)),
    binwidth = 1,
    fill = "red",
    colour = "black",
    alpha = .5
  ) +
  facet_grid(. ~ stratum,
    scales = "free_x"
  )
```

## Whats the pi? {#sec-what}

Now say we end up using `sample20` for _stratum A_ and `sample40` for _stratum B_. What pi's should we use when calculating the HT-estimator?

We should use the original _A_h_ (from the entire population), and the _n_ from the specific sample (i.e. 20 and 40 in this case, respectively.)

## Create function

Based on the above, and with the help of ChatGPT [version 5), I created a contained function
`nested_balanced_samples` that we can source in subsequent chapters.
You can fund in under `R/` in the [github repo](https://github.com/NINAnor/ANO_con).

```{r}
source(here::here("R/nested_balanced_samples.R"))
```


